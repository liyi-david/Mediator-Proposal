meta {
    author init "liyi";
}

function <size:int> next(pcurr:int 0 .. (size - 1)) : int 0 .. (size - 1) {
    return (pcurr + 1) % size ;
}

#-
in Queue and Stack, we introduces two approach to initialize a variable of unknown type:

1.  use a concrete type T, where T needs to be a `typedef .. init ... as ...`
2.  make a union type that comprises T and a initializable type, for simplicity you may 
    want to use NULL
-#

channel <T:type,size:int> Queue(A:in T, B:out T) {
    variables {
        buf : T | NULL [size] init null;
        phead : int 0 .. (size - 1) init 0;
        ptail : int 0 .. (size - 1) init 0;
    }
    transitions {
        _ -> B.reqWrite := (buf[ptail] != null) ;
        _ -> A.reqRead  := (buf[phead] == null) ;

        (A.reqRead && A.reqWrite) -> {
            perform A;
            buf[phead] := A;
            phead := next(phead);
        }

        (B.reqRead && B.reqWrite) -> {
            B := buf[ptail];
            ptail := next(ptail);
            perform B;
        }
    }
}

channel <T:type, size:int> Stack(A:in T, B:out T) {
    variables {
        # here T should be a concrete type
        buf : T [] ;
        p : int 0 .. (size - 1) init 0;
    }
    transitions {
        _ -> A.reqRead := (p < size - 1) ;
        _ -> B.reqWrite := (p > 0) ;
        
        (A.reqRead && A.reqWrite) -> {
            perform A;
            buf[p] := A;
            p := p + 1;
        }

        (B.reqRead && B.reqWrite) -> {
            p := p - 1;
            B := buf[p];
            perform B;
        }
    }
}